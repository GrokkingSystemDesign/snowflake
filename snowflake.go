package snowflake

import (
	"encoding/base64"
	"errors"
	"fmt"
	"strconv"
	"sync"
	"time"
)

const (
	// milliseconds of Feb 22 2022 22:22:22.222 UTC
	kEpoch int64 = 1645568542222

	machineBits  uint8 = 10
	sequenceBits uint8 = 12
)

// Machine is the abstract representation of a real single machine,
// the ID generated by the same machine should be monotonically increasing,
// but all IDs generated from all machines will be trendily increasing
type Machine struct {
	mu            sync.Mutex
	epoch         time.Time
	lastTimestamp int64
	machineID     int64
	sequenceID    int64

	maxMachineID   int64
	machineMask    int64
	sequenceMask   int64
	timestampShift uint8
	machineShift   uint8
}

// SnowflakeID refer to https://en.wikipedia.org/wiki/Snowflake_ID
// +-----------------------------------------------------------------------------+
// | 1 Bit Unused | 41 Bit Timestamp |  10 Bit MachineID  |   12 Bit Sequence ID |
// +-----------------------------------------------------------------------------+
type SnowflakeID int64

// New returns a machine that can be used to generate snowflake IDs
func NewMachine(machineID int64) (*Machine, error) {

	m := Machine{
		machineID:      machineID,
		maxMachineID:   -1 ^ (-1 << machineBits),
		machineMask:    (-1 ^ (-1 << machineBits)) << sequenceBits,
		sequenceMask:   -1 ^ (-1 << sequenceBits),
		timestampShift: machineBits + sequenceBits,
		machineShift:   sequenceBits,
	}

	if m.machineID < 0 || m.machineID > m.maxMachineID {
		return nil, fmt.Errorf("machine id can't be less than 0 or greater than %d", m.machineID)
	}

	var now = time.Now()
	// use monotonic clock instead of wall clock to ensure that time is monotonically increasing
	// From Go 1.9 (released August 24, 2017), Go uses a monotonic clock for durations
	// see https://pkg.go.dev/time@master#hdr-Monotonic_Clocks
	m.epoch = now.Add(time.Unix(kEpoch/1000, (kEpoch%1000)*1000000).Sub(now))

	return &m, nil
}

// Generate creates and returns a unique snowflake ID
func (m *Machine) Generate() (SnowflakeID, error) {
	m.mu.Lock()
	now := time.Since(m.epoch).Nanoseconds() / int64(time.Millisecond)
	if now < m.lastTimestamp {
		return SnowflakeID(0), errors.New("clock is moving backwards")
	}

	if now == m.lastTimestamp {
		m.sequenceID = (m.sequenceID + 1) & m.sequenceMask
		if m.sequenceID == 0 {
			for now <= m.lastTimestamp { // wait for next millisecond
				now = time.Since(m.epoch).Nanoseconds() / int64(time.Millisecond)
			}
		}
	} else {
		m.sequenceID = 0
	}

	m.lastTimestamp = now
	r := SnowflakeID((now)<<m.timestampShift |
		(m.machineID << m.machineShift) |
		(m.sequenceID),
	)
	m.mu.Unlock()
	return r, nil
}

func (f SnowflakeID) Int64() int64 {
	return int64(f)
}

func ParseInt64(id int64) SnowflakeID {
	return SnowflakeID(id)
}

func (f SnowflakeID) String() string {
	return strconv.FormatInt(int64(f), 10)
}

func (f SnowflakeID) Base64() string {
	return base64.StdEncoding.EncodeToString(f.Bytes())
}

func ParseBase64(id string) (SnowflakeID, error) {
	b, err := base64.StdEncoding.DecodeString(id)
	if err != nil {
		return -1, err
	}
	return ParseBytes(b)
}

func (f SnowflakeID) Bytes() []byte {
	return []byte(f.String())
}

func ParseBytes(id []byte) (SnowflakeID, error) {
	i, err := strconv.ParseInt(string(id), 10, 64)
	return SnowflakeID(i), err
}
